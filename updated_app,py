import ast
import os
import re
import textwrap
import logging
import concurrent.futures
from dotenv import load_dotenv
from radon.complexity import cc_visit
from radon.metrics import mi_visit
from radon.raw import analyze as raw_metrics
from prettytable import PrettyTable
import google.generativeai as genai
import javalang
import esprima
import pycparser

# Setup logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Load environment variables
load_dotenv(dotenv_path=os.getenv('GOOGLE_API_KEY_ENV', '.env'))

# Configure AI Key
API_KEY = os.getenv('GOOGLE_API_KEY') or os.getenv('GENAI_API_KEY')
if API_KEY:
    genai.configure(api_key=API_KEY)
else:
    logging.warning("No AI API key found. Skipping AI-powered analysis.")

# Keywords for detection
_LANGUAGE_KEYWORDS = {
    'python': ['def ', 'import ', 'print('],
    'javascript': ['function ', 'const ', 'let ', 'var '],
    'java': ['public ', 'class ', 'static ', 'void '],
    'c': ['#include', 'printf(', 'scanf('],
}

# Analyzer registry
ANALYZERS = {}

def register(lang):
    def wrapper(func):
        ANALYZERS[lang] = func
        return func
    return wrapper

def detect_language(code: str) -> str:
    scores = {
        lang: sum(len(re.findall(re.escape(kw), code)) for kw in keywords)
        for lang, keywords in _LANGUAGE_KEYWORDS.items()
    }
    top_lang, top_score = max(scores.items(), key=lambda x: x[1])
    if top_score == 0 or list(scores.values()).count(top_score) > 1:
        return 'unknown'
    return top_lang

def standard_metrics(code: str, funcs: int, loc: int, time_c: int = None) -> dict:
    if time_c is None:
        time_c = funcs * 2
    return {
        'functions': funcs,
        'loc': loc,
        'lloc': loc,  # placeholder for line-level logic
        'sloc': loc,  # placeholder for source lines of code
        'time_complexity': time_c,
        'space_complexity': loc * 2  # simple heuristic
    }

@register('python')
def analyze_python(code: str) -> dict:
    try:
        raw = raw_metrics(code)
        cc = cc_visit(code)
        tree = ast.parse(code)
        funcs = sum(isinstance(n, ast.FunctionDef) for n in ast.walk(tree))

        tbl = PrettyTable(["Function", "Complexity", "LOC", "Nesting"])
        time_c = 0
        for r in cc:
            depth = getattr(r, 'nested_blocks', 0)
            loc = r.endline - r.lineno + 1
            tbl.add_row([r.name, r.complexity, loc, depth])
            time_c += r.complexity

        return {
            'language': 'python',
            **standard_metrics(code, funcs, raw.loc, time_c),
            'mi': mi_visit(code, True),
            'table': tbl,
        }
    except Exception as e:
        raise ValueError("Python parser failed. Please ensure your code is valid Python.") from e

@register('javascript')
def analyze_js(code: str) -> dict:
    try:
        tree = esprima.parseScript(code)
        funcs = sum(isinstance(node, esprima.nodes.FunctionDeclaration) for node in tree.body)
        loc = code.count('\n') + 1
        return {
            'language': 'javascript',
            **standard_metrics(code, funcs, loc)
        }
    except Exception as e:
        raise ValueError("JavaScript parser failed. Ensure the code uses correct JavaScript syntax.") from e

@register('java')
def analyze_java(code: str) -> dict:
    try:
        tree = javalang.parse.parse(code)
        funcs = sum(1 for _, n in tree.filter(javalang.tree.MethodDeclaration))
        loc = code.count('\n') + 1
        return {
            'language': 'java',
            **standard_metrics(code, funcs, loc)
        }
    except Exception as e:
        raise ValueError("Java parser failed. Your code might include syntax from another language. Please submit only valid Java code.") from e

@register('c')
def analyze_c(code: str) -> dict:
    parser = pycparser.CParser()
    try:
        astree = parser.parse(code)
        funcs = sum(isinstance(n, pycparser.c_ast.FuncDef) for n in astree.ext)
        loc = code.count('\n') + 1
        return {
            'language': 'c',
            **standard_metrics(code, funcs, loc)
        }
    except pycparser.plyparser.ParseError as e:
        raise ValueError("C parser failed. Your code may include non-C syntax. Please ensure it's strictly in C.") from e

def ai_analysis(code: str, lang: str) -> str:
    if not API_KEY:
        return 'Skipped AI analysis.'
    prompt = textwrap.dedent(f"""
        Analyze this {lang} code briefly: summary, time/space complexity, refactoring areas and refactored code.
        Don't give out long explanations, just a clear and brief summary.

        {code}
    """)
    try:
        model = genai.GenerativeModel('gemini-2.0-flash')
        return model.generate_content(prompt).text.strip()
    except Exception as e:
        return f"AI error: {e}"

def run_analysis(code: str) -> None:
    lang = detect_language(code)
    if lang == 'unknown':
        logging.error("Ambiguous or mixed languages detected. Submit code in one language only.")
        return
    logging.info(f"Detected language: {lang}")
    try:
        with concurrent.futures.ThreadPoolExecutor() as executor:
            native_future = executor.submit(ANALYZERS[lang], code)
            ai_future = executor.submit(ai_analysis, code, lang)
            res = native_future.result()
            for k, v in res.items():
                print(v if k == 'table' else f"{k.title()}: {v}")
            print(f"\n\U0001F9E0 AI Insights:\n{ai_future.result()}")
    except Exception as e:
        logging.error(f"Analysis error: {e}")

def main():
    while True:
        print("Paste code (END to finish, EXIT to quit):")
        lines = []
        while True:
            try:
                line = input()
            except EOFError:
                print("\nExiting.")
                return
            if line.strip().upper() in ('END', 'EXIT'):
                break
            lines.append(line)
        if lines and lines[-1].strip().upper() == 'EXIT':
            break
        code = '\n'.join(lines)
        if code.strip():
            run_analysis(code)

if __name__ == '__main__':
    main()
